"""
Git Repository Operations
Handles cloning, branching, commits, and pull requests
"""
from typing import Dict, List, Optional
from git import Repo, GitCommandError
import os
from datetime import datetime
import asyncio


class RepositoryManager:
    """Manages git repository operations"""

    def __init__(self, workspace_root: str):
        self.workspace_root = workspace_root
        self.bot_name = os.getenv("GIT_BOT_NAME", "OrbitSpace-bot")
        self.bot_email = os.getenv("GIT_BOT_EMAIL", "support@orbitspace.org")

    async def clone_repository(
        self,
        repository_url: str,
        workspace_path: str,
        github_token: Optional[str] = None
    ) -> str:
        """
        Clone repository to workspace

        Args:
            repository_url: GitHub repository URL
            workspace_path: Destination path
            github_token: GitHub access token

        Returns:
            Path to cloned repository
        """
        # Extract repo name from URL
        repo_name = repository_url.rstrip('/').split('/')[-1].replace('.git', '')
        destination = os.path.join(workspace_path, repo_name)

        # Add token to URL if provided
        if github_token and 'github.com' in repository_url:
            # Convert https://github.com/user/repo to https://TOKEN@github.com/user/repo
            clone_url = repository_url.replace('https://', f'https://{github_token}@')
        else:
            clone_url = repository_url

        # Clone repository
        await asyncio.to_thread(
            Repo.clone_from,
            clone_url,
            destination,
            depth=1  # Shallow clone for speed
        )

        # Configure git user for this repo
        repo = Repo(destination)
        with repo.config_writer() as git_config:
            git_config.set_value('user', 'name', self.bot_name)
            git_config.set_value('user', 'email', self.bot_email)

        return destination

    async def create_feature_branch(
        self,
        repo_path: str,
        project_id: str,
        feature_slug: str
    ) -> str:
        """
        Create and push feature branch

        Args:
            repo_path: Path to repository
            project_id: Project identifier
            feature_slug: Feature description slug

        Returns:
            Branch name
        """
        repo = Repo(repo_path)

        # Generate branch name: compyle/{project-id}-{feature-slug}-{timestamp}
        timestamp = datetime.utcnow().strftime('%Y%m%d-%H%M%S')
        branch_name = f"compyle/{project_id}-{feature_slug}-{timestamp}"

        # Create new branch from current HEAD
        new_branch = await asyncio.to_thread(repo.create_head, branch_name)

        # Checkout new branch
        await asyncio.to_thread(new_branch.checkout)

        # Push branch to remote
        try:
            origin = repo.remote('origin')
            await asyncio.to_thread(
                origin.push,
                refspec=f'{branch_name}:{branch_name}'
            )
        except GitCommandError as e:
            print(f"Warning: Could not push branch to remote: {str(e)}")

        return branch_name

    async def commit_changes(
        self,
        repo_path: str,
        message: str,
        phase: str,
        project_id: str
    ) -> str:
        """
        Stage all changes and create commit

        Args:
            repo_path: Path to repository
            message: Commit message
            phase: Current phase
            project_id: Project identifier

        Returns:
            Commit SHA
        """
        repo = Repo(repo_path)

        # Stage all changes (modified, new, and deleted files)
        await asyncio.to_thread(repo.git.add, A=True)

        # Format commit message
        full_message = f"""[Compyle] {message}

Phase: {phase}
Project: {project_id}
Generated by Orbitspace Compyle
"""

        # Create commit
        commit = await asyncio.to_thread(
            repo.index.commit,
            full_message
        )

        # Push to remote
        try:
            origin = repo.remote('origin')
            await asyncio.to_thread(origin.push)
        except GitCommandError as e:
            print(f"Warning: Could not push commit to remote: {str(e)}")

        return commit.hexsha

    async def get_status(self, repo_path: str) -> Dict[str, List[str]]:
        """
        Get repository status

        Args:
            repo_path: Path to repository

        Returns:
            Dictionary with modified, untracked files
        """
        repo = Repo(repo_path)

        # Get modified files
        modified = [item.a_path for item in repo.index.diff(None)]

        # Get staged files
        staged = [item.a_path for item in repo.index.diff('HEAD')]

        # Get untracked files
        untracked = repo.untracked_files

        return {
            "modified": modified,
            "staged": staged,
            "untracked": untracked,
            "branch": repo.active_branch.name,
            "has_changes": len(modified) > 0 or len(staged) > 0 or len(untracked) > 0
        }

    async def get_diff(self, repo_path: str) -> str:
        """
        Get unified diff of changes

        Args:
            repo_path: Path to repository

        Returns:
            Unified diff string
        """
        repo = Repo(repo_path)

        # Get diff of all changes (staged and unstaged)
        diff_staged = await asyncio.to_thread(
            repo.git.diff,
            'HEAD',
            unified=3
        )

        diff_unstaged = await asyncio.to_thread(
            repo.git.diff,
            unified=3
        )

        # Combine both diffs
        combined_diff = ""
        if diff_staged:
            combined_diff += "=== Staged Changes ===\n" + diff_staged + "\n\n"
        if diff_unstaged:
            combined_diff += "=== Unstaged Changes ===\n" + diff_unstaged

        return combined_diff if combined_diff else "No changes"

    async def push_branch(self, repo_path: str) -> bool:
        """
        Push current branch to remote

        Args:
            repo_path: Path to repository

        Returns:
            True if successful
        """
        try:
            repo = Repo(repo_path)
            origin = repo.remote('origin')
            await asyncio.to_thread(origin.push)
            return True
        except GitCommandError as e:
            print(f"Error pushing branch: {str(e)}")
            return False
